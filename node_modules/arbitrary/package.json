{
  "_args": [
    [
      {
        "raw": "arbitrary",
        "scope": null,
        "escapedName": "arbitrary",
        "name": "arbitrary",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "D:\\Git\\UBCcards-develop"
    ]
  ],
  "_from": "arbitrary@latest",
  "_id": "arbitrary@1.4.6",
  "_inCache": true,
  "_location": "/arbitrary",
  "_nodeVersion": "4.8.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/arbitrary-1.4.6.tgz_1489343864434_0.4041771695483476"
  },
  "_npmUser": {
    "name": "francoislaberge",
    "email": "francoislaberge@gmail.com"
  },
  "_npmVersion": "2.15.11",
  "_phantomChildren": {},
  "_requested": {
    "raw": "arbitrary",
    "scope": null,
    "escapedName": "arbitrary",
    "name": "arbitrary",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/arbitrary/-/arbitrary-1.4.6.tgz",
  "_shasum": "7d2c728c31e550e27390068981125002f7f55ec6",
  "_shrinkwrap": null,
  "_spec": "arbitrary",
  "_where": "D:\\Git\\UBCcards-develop",
  "author": {
    "name": "Francois Laberge",
    "email": "francoislaberge@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/francoislaberge/arbitrary/issues"
  },
  "dependencies": {},
  "description": "Efficient Reversible Number Generator",
  "devDependencies": {
    "babel-preset-es2015": "^6.9.0",
    "babelify": "^7.3.0",
    "browserify": "^13.0.1",
    "mapstraction": "^1.0.0",
    "mocha": "^2.3.4",
    "watchify": "^3.7.0"
  },
  "directories": {},
  "dist": {
    "shasum": "7d2c728c31e550e27390068981125002f7f55ec6",
    "tarball": "https://registry.npmjs.org/arbitrary/-/arbitrary-1.4.6.tgz"
  },
  "gitHead": "e29f405a26f84d0a74da811d0c2a9a07879fa21f",
  "homepage": "https://github.com/francoislaberge/arbitrary",
  "keywords": [
    "lcg",
    "rlcg",
    "reversible",
    "linear congruent generator",
    "generative",
    "deterministic",
    "random number generator",
    "rng"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "francoislaberge",
      "email": "francoislaberge@gmail.com"
    }
  ],
  "name": "arbitrary",
  "optionalDependencies": {},
  "readme": "# Overview\n<a href=\"https://travis-ci.org/francoislaberge/arbitrary\"><img src=\"https://api.travis-ci.org/francoislaberge/arbitrary.svg\" alt=\"Build Status\"></a>\n\nA deterministic and reversible random number generator.\n\nIdeal for generative art, as well as games for varied entity behavior.\n\n<img src=\"http://francoislaberge.com/arbitrary/images/screenshot.png\" width=\"100%\"/>\n\n\n## Features\n\n  - Is deterministic (provide the same seed to get same stream of random values)\n  - Is reversible (see [next/prev](#reversing) section)\n  - Internal state only takes up 32bits\n  - Has a period length of 2^32\n  - Each value from [0, 2^32) is generated exactly once in the total period\n  - Has great test coverage\n\n# Demos\n - [Samples](http://francoislaberge.com/arbitrary/examples/tests.html)\n\n# Installation\n\n```\nnpm install arbitrary\n```\n\n# Usage\n\n## Basics\n\n```js\nimport arbitrary from 'arbitrary';\n\n// Creates a Generator with a random seed.\nlet generate = new arbitrary.Generator();\n\nconsole.log( generate.next.number(-10, 10) );\nconsole.log( generate.next.percent() );\nconsole.log( generate.next.bits(1) );\nconsole.log( generate.next.bits(32) );\n```\n\n## Deterministic\n```js\nimport arbitrary from 'arbitrary';\n// Create a Generator with a seed\nlet deterministic = new arbitrary.Generator(42);\n\n// Will always be: 0.2523451747838408\nconsole.log( deterministic.next.percent() );\n// Will always be: 22\nconsole.log( deterministic.next.bits(8) );\n// Will always be: 5772.811982315034\nconsole.log( deterministic.next.number(0, 10000) );\n```\n\n## Reversing\n\n```js\nimport arbitrary from 'arbitrary';\n\n// Create a Generator with a seed\nlet generate = new arbitrary.Generator();\n\nconsole.log( generate.next.number(0, 10000) );\nconsole.log( generate.next.number(-10, 10) );\nconsole.log( generate.next.percent() );\nconsole.log( generate.next.bits(1) );\nconsole.log( generate.next.bits(32) );\n\n// Now generate the reverse stream of the above numbers\nconsole.log( generate.prev.bits(1) );\nconsole.log( generate.prev.percent() );\nconsole.log( generate.prev.number(-10, 10) );\nconsole.log( generate.prev.number(0, 10000) );\n\n/**\nOutput will be:\n\n    0.734807450324297\n    -3.3194907444994897\n    0.9332054262049496\n    1\n    3735025540\n    1\n    0.9332054262049496\n    -3.3194907444994897\n    0.734807450324297\n*/\n```\n\n## Scramble / Descramble\nThe scramble function is best used for turning sequences of ordered numbers (Ex. an increasing counter)\nand scrambling the bits to get random number. It also reversible via `arbitrary.descramble()`.\n\nA few obvious utilizing scrambling:\n 1. Jump back and forward in a stream of randomly generated numbers.\n   - To do this, keep an index into a sequence and scramble the index you want a random number. Just\n     jump or set the index to another point and scramble it again to recoup the random number generated\n     at that point in time.\n   - For comparison using `Generator .next/.prev` can be forwarded/reversed, but\n     it can only do so a single step at a time, making large jumps in a sequence\n     take proportionally more CPU per distance jumped.\n 2. Use scramble to take a `Generate` state and jump to another point in the sequence it generates.\n   - This is useful for instance when creating generative art and wanting to fork a\n     new stream of random values.\n\n**Important**: Use Generator .next/.prev if\nyou don't need this focus but just want a series of random numbers as `scramble`/`unscramble` are computationally\nmore expensive.\n\n```js\nimport arbitrary from 'arbitrary';\n\n// Scramble the bits of an unsigned 32 bit integer\nconst scrambled42 = arbitrary.scramble(42);\n    // Should print '1077848774'\nconsole.log(scrambled42);\n\n// Reverse the scrambling to get back the original number\nconst unscrambled42 = arbitrary.descramble(scrambled42);\n    // Should print '42'\nconsole.log(unscrambled42)\n```\n\n## API Reference\nComing soon. See examples above.\n\n\n## Contributing\n\n#### Setup\n```\ngit clone git@github.com:francoislaberge/arbitrary.git\ncd arbitrary\n```\n\n#### Watching\n```\nnpm run watch\n```\n\n#### Building\n```\nnpm run build\n```\n\n#### Publishing to NPM\nDo the usual npm version bump then publish.\n```\nnpm version <major|minor|patch>\ngit push; git push --tags\nnpm publish\n```\n\n#### Test\nThe tests must be built before they can be run. So use either the build or watch approach below before running the tests.\n\nAll tests are run automatically on push via [our travis-ci integration](https://travis-ci.org/francoislaberge/arbitrary)\n\n```\nnpm run test\n```\n\n#### Watch Tests\nAutomatically builds tests when any source code changes (test or regular).\n\n```\nnpm run watch-test\n```\n\n#### Build Tests\n```\nnpm run build-test\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/francoislaberge/arbitrary.git"
  },
  "scripts": {
    "build": "npm run clean && ./node_modules/.bin/browserify -s arbitrary -t [ babelify ] src/index.js -o lib/index.js -p mapstraction --debug",
    "build-test": "npm run clean-test && ./node_modules/.bin/browserify -t [ babelify ] tests/index.js -o lib-tests/index.js -p mapstraction --debug",
    "clean": "rm -rf lib; mkdir lib",
    "clean-test": "rm -rf lib-tests; mkdir lib-tests",
    "prepublish": "npm run build",
    "test": "mocha lib-tests",
    "watch": "npm run clean && ./node_modules/.bin/watchify -s arbitrary src/index.js -t [ babelify ] -o lib/index.js -p mapstraction --debug",
    "watch-test": "npm run clean-test && ./node_modules/.bin/watchify tests/index.js -t [ babelify ] -o lib-tests/index.js -p mapstraction --debug"
  },
  "version": "1.4.6"
}
